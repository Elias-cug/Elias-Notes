## 工厂模式
1. 缺点：没有解决对象识别问题

## 构造函数模式
1. 优点：解决了工厂公式 **对象识别**的问题
2. 缺点：重复实例化函数对象
3. 改进：将方法定义在全局，通过引用赋值的方式再给对象中方法赋值
4. 改进依然存在问题

## 原型模式
1. 实现基础：

每个函数都有一个原型属性 prototype，通过构造函数实例化的对象共享此原型属性。

2. 一些知识：
```js
Person, Person.prototype, Person.prototype.contructor, person1, person1.__proto__Person

isPrototypeOf(), Object.getPrototypeOf(), hasOwnProperty
```

3. 缺点
- 实例在默认情况下都将取得相同的属性值
- 引用类型值属性，一个实例对象更改后会影响其他实例的值

## 组合使用构造函数模式和原型模式

1. 这种构造函数和原型模式混成的模式，是目前 ECMAScript 中使用最广泛、认同度最高的一种创建自定义类型的方法。

## 动态原型模式

1. 解决*构造函数 + 原型模式*构造函数和原型相互独立问题

## 寄生构造函数模式

1. 工厂函数寄生在了构造函数模式上
2. 不建议使用

## 稳妥构造函数模式

1. 特点：没有公共属性，方法不引用 this 对象。
2. 安全环境中使用
