<!-- GFM-TOC -->
* [20200319](#20200319)
<!-- GFM-TOC -->

## 20200319

### 学习JavaScript数据结构与算法第五章
- 创建普通队列
```js
class Queue {
    constructor() {
        this.count = 0; 
        this.lowestCount = 0;
        this.items = {};
    }
    // 向队列添加元素
    enqueue(element) {
        this.items[this.count] = element;
        this.count++;
    }
    // 删除队列元素
    dequeue() {
        if (this.isEmpty()){
            return undefined;
        }
        const result = this.items[this.lowestCount];
        delete this.items[this.lowestCount];
        this.lowestCount++;
        return result;
    }
    // 查看队列头元素
    peek() {
        if (this.isEmpty()) {
            return undefined;
        }
        return this.items[this.lowestCount];
    }
    // 查看队列是否为空
    isEmpty() {
        return this.count - this.lowestCount === 0;
    }
    // 获取队列长度
    size() {
        return this.count - this.lowestCount;
    }
    // 清空队列
    clear() {
        this.count = 0;
        this.lowestCount = 0;
        this.items = {};
    }
    // toString方法
    toString() {
        if (this.isEmpty()) {
            return undefined;
        }
        let objString = `${this.items[this.lowestCount]}`;
        for (let i = this.lowestCount + 1; i < this.count; i++) {
            objString = `${objString}, ${this.items[i]}`;
        }
        return objString;
    }
}
```
- 创建双端队列
```js
class Deque {
    constructor() {
        this.count = 0;
        this.lowestCount = 0;
        this.items = {};
    }
    // 向双端队列的前端添加元素
    addFront(element) {
        if (this.isEmpty()) {
            this.addBack(element);
        } else if (this.lowestCount > 0) {
            this.lowestCount--;
            this.items[this.lowestCount] = element;
        } else {
            for (let i = this.count; i > 0; i--) {
                this.items[i] = this.items[i - 1];
            }
            this.items[0] = element;
            this.lowestCount = 0;
            this.count++
        }
    }
    // 向双端队列的后端添加元素
    addBack(element) {
        this.items[this.count] = element;
        this.count++; 
    }
    // 从双端队列前端移除第一个元素
    removeFront() {
        const result = this.items[this.lowestCount];
        delete this.items[this.lowestCount];
        this.lowestCount++;
        return result;
    }
    // 从双端队列后端移除第一个元素
    removeBack() {
        this.count--;
        const result = this.items[this.count]
        delete this.items[this.count];
        return result;
    }
    // 返回双端队列前端的第一个元素
    peekFront() {
        return this.items[this.lowestCount];
    }
    // 返回双端队列后端的第一个元素
    peekBack() {
        return this.items[this.count]
    }
    // 判断队列是否为空
    isEmpty() {
        return this.count - this.lowestCount === 0;
    }
    // 返回队列长度
    size() {
        return this.count - this.lowestCount;
    }
    // 清空队列
    clear() {
        this.count = 0;
        this.lowestCount = 0;
        this.items = {};
    }
    // toString 方法
    toString() {
        if(this.isEmpty()) {
            return undefined;
        }
        let objString = `${this.items[this.lowestCount]}`;
        for (let i = this.lowestCount + 1; i < this.count; i++) {
            objString = `${objString}, ${this.items[i]}`;
        }
        return objString;
    }
}
```
- 击鼓传花实现
```js
const Queue = require('./creatQueue')
function hotPatato(elementsList) {
    const queue = new Queue();
    let elimatedList = [];
    // 给队列 queue 赋值
    for (let i = 0; i < elementsList.length; i++) {
        queue.enqueue(elementsList[i]);
    }
    // 循环队列
    while (queue.size() > 1) {
        let random = Math.floor(Math.random() * 19 + 1);
        for (let i = 0; i < random; i++) {
            queue.enqueue(queue.dequeue());
        }
        elimatedList.push(queue.dequeue());
    }
    return {
       elimated: elimatedList,
       Winner: queue.dequeue()  
    }
}
const names = ['a','b','c','d','e','f','g'];
const result = hotPatato(names);
result.elimated.forEach(name => {
    console.log(`${name}在击鼓传花游戏中被淘汰。`)
})
console.log(`胜利者：${result.Winner}`)
```
- 回文检查器
```js
const Deque = require('./creatDeque');

function palindromeChecker(aString) {
    if (aString === undefined || aString === null 
        || (aString !== null && aString.length === 0)) {
        return false;
    }
    const deque = new Deque();
    const lowerString = aString.toLocaleLowerCase().split(' ').join('');
    let isEqual = true;
    let firstChar = '',
        lastChar = '';
    for (let i = 0; i < lowerString.length; i++) {
        deque.addBack(lowerString.charAt(i));
    }
    while(deque.size() > 1 && isEqual) {
        firstChar = deque.removeFront();
        lastChar = deque.removeBack();
        if (firstChar !== lastChar) {
            isEqual = false;
        }
    }
    return isEqual;
}
```
- 涉及知识点
1、node中模块的实现：基于commonJS，使用module.export和require
2、node环境中无法实现ES6的模块实现

### B站网络通信概述（11-12）
- UDP发送数据
